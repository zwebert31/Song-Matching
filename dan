#! /usr/bin/python
#Zach Webert
#Katie Gilligan
#Sam Lynch
#Kevin Doherty

import sys
import wave
import numpy
import os.path
import scipy.io.wavfile
import scipy.spatial.distance as dist
import os
import uuid
from multiprocessing.pool import ThreadPool
from subprocess import call

# Size of our chunks
CHUNK_SIZE = 4410

# CD quality sampling rate used to determine chunk time
CD_SAMPLE_RATE = 44100.0

# Minimum length of matches in seconds
MIN_MATCH_LENGTH = 5

# How close hashes need to be to be considered a match
DISTANCE_THRESHOLD = 0.001

# Still considered a match but we don't return immediatly, look for lowest distance
SECOND_DISTANCE_THRESHOLD = 0.0035 

# Number of decimal places to round to
HASH_PRECISION = 1

# Time each chunk. This is based on the size of chunks
CHUNK_TIME = float(CHUNK_SIZE) / CD_SAMPLE_RATE

# Size of fragments
FRAGMENT_SIZE = int(MIN_MATCH_LENGTH / CHUNK_TIME)

# Supported file extensions
SUPPORTED_EXTENSIONS = [".wav", ".mp3", ".ogg"]

# Cache which stores data about each song
# Key is the absolute path of the file
# and value is the data
johnnySongDataCache = {}

# Enable / disables debug prints
debug = False

#Print an error to standard error
#ERROR CODE 1: Invalid command line
#ERROR CODE 2: Invalid file format
def throwError(code, arg=""):
    if code == 1:
        sys.stderr.write("ERROR: incorrect command line\n")
    elif code == 2:
        sys.stderr.write("ERROR: " + formatFileName(arg)
                         + " is not a supported format\n")
    else:
        sys.stderr.write("ERROR: there was a problem\n")
    exit(code)

#returns the relative file name of the file
def formatFileName(path):
    tmp = []

    for i in range (0, len(path)):
        if path[i] == '/':
           tmp = []
        else:
           tmp.append(path[i])

    formatted_str = ''.join(tmp)
    return formatted_str

#returns the extension of the file
def getExtension(path):
    return os.path.splitext(path)[1]

#returns True if extension is supported, False if not supported
def isSupportedExtension(path):
    extension = getExtension(path)
    return extension in SUPPORTED_EXTENSIONS

# Returns a path to a wav file.
# If the file is a wav file already, the input path is returned
# Otherwise the file is converted to a .wav file and stored in a /tmp path
def fileToWave(filePath):

    fileExtension = getExtension(filePath)

    if fileExtension == ".wav":
        return filePath

    basePath = "/tmp/waveFiles"
    tmpPath = os.path.join(basePath + str(uuid.uuid4()))

    if not os.path.exists(tmpPath):
        os.makedirs(tmpPath)

    formattedFileName = formatFileName(filePath)
    outputPath = ""

    if fileExtension == ".ogg":
        outputPath = os.path.join(tmpPath, "%s.ogg" % formattedFileName[:-4])
        call(["/usr/bin/oggdec", filePath, "-o", outputPath, "--quiet"])

    if fileExtension == ".mp3":
        outputPath = os.path.join(tmpPath, "%s.mp3" % formattedFileName[:-4])
        call(["/course/cs4500f14/bin/lame","--resample", "44.1", "--decode", "--silent",
                  filePath, outputPath
                  ])

    return outputPath 

# Gets info about the song at the specified path
def getInfo(path, chunkSize):

    if path in johnnySongDataCache:
        if debug:
            print "Using cached song data for " + path 
        return johnnySongDataCache[path]

    tempWavPath = fileToWave(path)
    wave_results = scipy.io.wavfile.read(tempWavPath)
    samplingRate = wave_results[0]
    # Array of samples
    wave_data = wave_results[1]
    sampleCount = len(wave_data)

    channels = wave.open(tempWavPath, 'r').getnchannels()
    if (channels == 2):
        # Convert stereo to mono by averaging the channels 
        wave_mono = wave_data.mean(axis=1)  
    else:
        wave_mono = wave_data

    songDict = {}
    chunks = []
    hashArr = []
    for i in range(0, sampleCount / chunkSize):
        startBounds = i * chunkSize
        endBounds = (i+1) * chunkSize 
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])          

        fftChunk = map(abs, fftChunk)
        fftChunk = map(sqaure, fftChunk)
        fftMax = numpy.amax(fftChunk)
        if (fftMax == 0):
            fftMax = 1
        fftChunk = [x / len(fftChunk) / fftMax for x in fftChunk]
        chunks.append(numpy.sum(fftChunk))
        if (i > FRAGMENT_SIZE):
            hashPrint = round(hash(chunks[i - FRAGMENT_SIZE : i]), HASH_PRECISION)
            songDict.setdefault(hashPrint,[]).append(i - FRAGMENT_SIZE)
            hashArr.append(hashPrint)

    result = { "energies":chunks, "hashDict":songDict, "hashArr":hashArr }
    johnnySongDataCache[path] = result

    return result

def hash(chunkArray):
    weight = 1
    hashValue = 0;
    for x in chunkArray:
        hashValue += (x * weight)
        weight += 1

    return hashValue

def sqaure(x):
    return x * x

def checkMatch(path1, path2):

    if not isSupportedExtension(path1):
    	throwError(2, path1)
    if not isSupportedExtension(path2):
    	throwError(2, path2)

    info1 = getInfo(path1, CHUNK_SIZE)
    info2 = getInfo(path2, CHUNK_SIZE) 
    
    minDist = 100
    song1Index = -1
    song2Index = -1

    for i in range(0, len(info1["energies"]) - FRAGMENT_SIZE - 1):
        checkList = info2["hashDict"].get(info1["hashArr"][i])
        if checkList:
            for index in checkList:
                distance = dist.euclidean(info1["energies"][i:i+FRAGMENT_SIZE], info2["energies"][index:index+FRAGMENT_SIZE])
                if distance < DISTANCE_THRESHOLD:
                    print "MATCH " + formatFileName(path1) + " " + formatFileName(path2) + " " + str(i * CHUNK_TIME) + " " + str(index * CHUNK_TIME)
		    if debug:
 		        print "Distance: " + str(distance)
 		    return
                if distance < SECOND_DISTANCE_THRESHOLD and distance < minDist: 
                    minDist = distance
                    song1Index = i
                    song2Index = index
                    
    if not song1Index == -1:
        if debug:
            print "Second threshold match found with distance: " + str(distance)
        print "MATCH " + formatFileName(path1) + " " + formatFileName(path2) + " " + str(song1Index * CHUNK_TIME) + " " + str(song2Index * CHUNK_TIME)
 
#MAIN

#check for valid command line input
if len(sys.argv) != 5 and len(sys.argv) != 6:
    throwError(1)    

if len(sys.argv) == 6:
    if sys.argv[5] == '--debug':
        debug = True
    else: 
        throwError(1)
    
if ((sys.argv[1] != '-f' and sys.argv[1] != '-d') or
   (sys.argv[3] != '-f' and sys.argv[3] != '-d')):
    throwError(1)

pathList1 = []
pathList2 = []
if (sys.argv[1] == '-f'):
    pathList1.append(sys.argv[2])
elif (sys.argv[1] == '-d'):
    if os.path.exists(sys.argv[2]) and os.path.isdir(sys.argv[2]):
        files = os.listdir(sys.argv[2])
        for f in files:
            pathList1.append(os.path.join(sys.argv[2], f))        
    else:
        throwError(1)    
if (sys.argv[3] == '-f'):
    pathList2.append(sys.argv[4])
elif (sys.argv[3] == '-d'):
    if os.path.exists(sys.argv[4]) and os.path.isdir(sys.argv[4]):
        files = os.listdir(sys.argv[4])
        for f in files:
            pathList2.append(os.path.join(sys.argv[4], f))        
    else:
        throwError(1)

for s1 in pathList1:
    for s2 in pathList2:
        checkMatch(s1, s2)

#exit with status of 0 as specified in directions
exit(0)
