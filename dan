#! /usr/bin/python
#Zach Webert
#Katie Gilligan
#Sam Lynch
#Kevin Doherty

import sys
import wave
import numpy
import os.path
import scipy.io.wavfile
import scipy.spatial.distance as dist
import os
import uuid
from multiprocessing.pool import ThreadPool
from subprocess import call

# Enable / disables debug prints
DEBUG = False

# Chunk size
CHUNK_SIZE = 4410

DISTANCE_THRESHOLD = 0.001

# Supported file extensions
SUPPORTED_EXTENSIONS = [".wav", ".mp3", ".ogg"]

# Cache which stores data about each song
# Key is the absolute path and value is the data
songDataCache = {}

#Print an error to standard error
#ERROR CODE 1: Invalid command line
#ERROR CODE 2: Invalid file format
def throwError(code, arg=""):
    if code == 1:
        sys.stderr.write("ERROR: incorrect command line\n")
    elif code == 2:
        sys.stderr.write("ERROR: " + formatFileName(arg)
                         + " is not a supported format\n")
    else:
        sys.stderr.write("ERROR: there was a problem\n")
    exit(code)

#returns the relative file name of the file
def formatFileName(path):
    tmp = []

    for i in range (0, len(path)):
        if path[i] == '/':
           tmp = []
        else:
           tmp.append(path[i])

    formatted_str = ''.join(tmp)
    return formatted_str

#returns the extension of the file
def getExtension(path):
    return os.path.splitext(path)[1]

#returns True if extension is supported, False if not supported
def isSupportedExtension(path):
    extension = getExtension(path)
    return extension in SUPPORTED_EXTENSIONS

# Returns a path to a wav file.
# If the file is a wav file already, the input path is returned
# Otherwise the file is converted to a .wav file and stored in a /tmp path
def fileToWave(filePath):

    fileExtension = getExtension(filePath)

    if fileExtension == ".wav":
        return filePath

    basePath = "/tmp/waveFiles"
    tmpPath = os.path.join(basePath + str(uuid.uuid4()))

    if not os.path.exists(tmpPath):
        os.makedirs(tmpPath)

    formattedFileName = formatFileName(filePath)
    outputPath = ""

    if fileExtension == ".ogg":
        outputPath = os.path.join(tmpPath, "%s.ogg" % formattedFileName[:-4])
        call(["/usr/bin/oggdec", filePath, "-o", outputPath, "--quiet"])

    if fileExtension == ".mp3":
        outputPath = os.path.join(tmpPath, "%s.mp3" % formattedFileName[:-4])
        call(["./lame","--resample", "44.1", "--decode", "--silent",
                  filePath, outputPath
                  ])

    return outputPath 

#path to wavfile -> 
def getInfo(path, chunkSize):

    if path in songDataCache:
        return songDataCache[path]

    tempWavPath = fileToWave(path)
    wave_results = scipy.io.wavfile.read(tempWavPath)
    samplingRate = wave_results[0]
    # Array of samples
    wave_data = wave_results[1]
    sampleCount = len(wave_data)

    channels = wave.open(tempWavPath, 'r').getnchannels()
    if (channels == 2):
        # Convert stereo to mono by averaging the channels 
        wave_mono = wave_data.mean(axis=1)  
    else:
        wave_mono = wave_data

    songDict = {}
    chunks = []
    hashArr = []
    for i in range(0, sampleCount / chunkSize):
        startBounds = i * chunkSize
        endBounds = (i+1) * chunkSize 
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])          

        fftChunk = map(abs, fftChunk)
        fftChunk = map(sqaure, fftChunk)
        fftMax = numpy.amax(fftChunk)
        if (fftMax == 0):
            fftMax = 1
        fftChunk = [x / len(fftChunk) / fftMax for x in fftChunk]
        #fftChunk = [x / fftMax for x in fftChunk]
        chunks.append(numpy.sum(fftChunk))
        if (i > 50):
            hashPrint = round(hash(chunks[i - 50 : i]), 1)
            songDict.setdefault(hashPrint,[]).append(i - 50)
            hashArr.append(hashPrint)

    result = { "energies":chunks, "hashDict":songDict, "hashArr":hashArr }
    songDataCache[path] = result

    return result

def hash(chunkArray):
    weight = 1
    hashValue = 0;
    for x in chunkArray:
        hashValue += (x * weight)
        weight += 1

    return hashValue

def sqaure(x):
    return x * x


def checkMatch(path1, path2):

    # TODO: Check if supported extension and throw expected error or take out method

    #.1 second energy chunks

    print "Starting getInfo calls"

    info1 = getInfo(path1, CHUNK_SIZE)
    info2 = getInfo(path2, CHUNK_SIZE)
    #pool = ThreadPool(processes=2)

    #async_result1 = pool.apply_async(getInfo, (path1, CHUNK_SIZE))
    #async_result2 = pool.apply_async(getInfo, (path2, CHUNK_SIZE))

    #info1 = async_result1.get()
    #print "info1 finished"
    #info2 = async_result2.get()
    #print "info2 finished"
    #print info2["energies"]

    #t1 = threading.Thread(target=getInfo, args=(path1, CHUNK_SIZE, ))
    #t1.start()
    #t2 = threading.Thread(target=getInfo, args=(path2, CHUNK_SIZE, ))
    #t2.start()
    #t1.join()
    #t2.join()

    fragmentSize = 50   
    hashThresh = 100
    chunkTime = CHUNK_SIZE / 44100.0

    for i in range(0, len(info1["energies"]) - fragmentSize - 1):
        checkList = info2["hashDict"].get(info1["hashArr"][i])
        if checkList:
            for index in checkList:
                distance = dist.euclidean(info1["energies"][i:i+fragmentSize], info2["energies"][index:index+fragmentSize])
                if distance < DISTANCE_THRESHOLD:
                    print "MATCH " + formatFileName(path1) + " " + formatFileName(path2) + " " + str(i * chunkTime) + " " + str(index * chunkTime)
		    if DEBUG:
 		        print "Distance: " + str(distance)
                    return

#MAIN
#check for valid command line input

if len(sys.argv) != 5 and len(sys.argv) != 6:
    throwError(1)    

if len(sys.argv) == 6:
    if sys.argv[5] == '--debug':
        DEBUG = True
    else: 
        throwError(1)
    
if ((sys.argv[1] != '-f' and sys.argv[1] != '-d') or
   (sys.argv[3] != '-f' and sys.argv[3] != '-d')):
    throwError(1)

pathList1 = []
pathList2 = []
if (sys.argv[1] == '-f'):
    pathList1.append(sys.argv[2])
elif (sys.argv[1] == '-d'):
    if os.path.exists(sys.argv[2]) and os.path.isdir(sys.argv[2]):
        files = os.listdir(sys.argv[2])
        for f in files:
            pathList1.append(os.path.join(sys.argv[2], f))        
    else:
        throwError(1)    
if (sys.argv[3] == '-f'):
    pathList2.append(sys.argv[4])
elif (sys.argv[3] == '-d'):
    if os.path.exists(sys.argv[4]) and os.path.isdir(sys.argv[4]):
        files = os.listdir(sys.argv[4])
        for f in files:
            pathList2.append(os.path.join(sys.argv[4], f))        
    else:
        throwError(1)

for s1 in pathList1:
    for s2 in pathList2:
        checkMatch(s1, s2)

#exit with status of 0 as specified in directions
exit(0)

