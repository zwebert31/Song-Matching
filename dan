#! /usr/bin/python
#Zach Webert
#Katie Gilligan
#Sam Lynch
#Kevin Doherty

import sys
import wave
import numpy
import os.path
import scipy.io.wavfile
import scipy.spatial.distance as dist
import os
import uuid
from subprocess import call

# Enable / disables debug prints
DEBUG = False

# How much our fftId can be off by and still be considered the same
ALLOWED_MATCH_ERROR = 5

# Minimum percentage of matches that must 
# be found in order to signify a match
MATCH_CERTAINTY = 60

# Chunk size
CHUNK_SIZE = 4410

# Time per chunk
CHUNK_TIME = .1

# Cache which stores data about each song
# Key is the absolute path and value is the data
songDataCache = {}

#Print an error to standard error
#ERROR CODE 1: Invalid command line
#ERROR CODE 2: Invalid file format
def throwError(code, arg=""):
    if code == 1:
        sys.stderr.write("ERROR: incorrect command line\n")
    elif code == 2:
        sys.stderr.write("ERROR: " + formatFileName(arg)
                         + " is not a supported format\n")
    else:
        sys.stderr.write("ERROR: there was a problem\n")
    exit(code)

#returns the relative file name of the file
def formatFileName(path):
    tmp = []

    for i in range (0, len(path)):
        if path[i] == '/':
           tmp = []
        else:
           tmp.append(path[i])

    formatted_str = ''.join(tmp)
    return formatted_str

#returns the extension of the file
def getExtension(path):
    return os.path.splitext(path)[1]

#returns 1 if extension is valid, 0 if invalid
def isValidExtension(path):
    extension = getExtension(path)
    extensions = [".wav", ".mp3", ".ogg"]
    return extension in extensions

# Returns a path to a wav file.
# If the file is a wav file already, the input path is returned
# Otherwise the file is converted to a .wav file and stored in a /tmp path
def fileToWave(filePath):
    if getExtension(filePath) == ".wav":
        return filePath

    basePath = "/tmp/waveFiles"
    tmpPath = os.path.join(basePath + str(uuid.uuid4()))

    if not os.path.exists(tmpPath):
        os.makedirs(tmpPath)

    formattedFileName = formatFileName(filePath)
    outputPath = ""

    if getExtension(filePath) == ".ogg":
        outputPath = os.path.join(tmpPath, "%s.ogg" % formattedFileName[:-4])
        call(["/usr/bin/oggdec", filePath, "-o", outputPath, "--quiet"])

    if getExtension(filePath) == ".mp3":
        outputPath = os.path.join(tmpPath, "%s.mp3" % formattedFileName[:-4])
        call(["./lame","--resample", "44.1", "--decode", "--silent",
                  filePath, outputPath
                  ])

    return outputPath 

#path to wavfile -> 
def getInfo(path, chunkSize):
    #TODO remove
   # path = fileToWave(path);

    if path in songDataCache:
        return songDataCache[path]

    tempWavPath = fileToWave(path)
    wave_results = scipy.io.wavfile.read(tempWavPath)
    samplingRate = wave_results[0]
    # Array of samples
    wave_data = wave_results[1]
    sampleCount = len(wave_data)

    channels = wave.open(tempWavPath, 'r').getnchannels()
    if (channels == 2):
        # Convert stereo to mono by averaging the channels 
        wave_mono = wave_data.mean(axis=1)  
    else:
        wave_mono = wave_data

    songDict = {}
    chunks = []
    hashArr = []
    for i in range(0, sampleCount / chunkSize):
        startBounds = i * chunkSize
        endBounds = (i+1) * chunkSize 
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])          

        fftChunk = map(abs, fftChunk)
        fftChunk = map(sqaure, fftChunk)
        fftMax = numpy.amax(fftChunk)
        if (fftMax == 0):
            fftMax = 1
        fftChunk = [x / len(fftChunk) / fftMax for x in fftChunk]
        #fftChunk = [x / fftMax for x in fftChunk]
        chunks.append(numpy.sum(fftChunk))
        if (i > 50):
            hashPrint = round(hash(chunks[i-50:i]))
            songDict.setdefault(hashPrint,[]).append(i-50)
            hashArr.append(hashPrint)

    result = {"energies":chunks, "hashDict":songDict, "hashArr":hashArr}
    songDataCache[path] = result
    return result

def hash(chunkArray):
    weight = 1
    hashValue = 0;
    for x in chunkArray:
        hashValue += (x * weight)
        weight += 1;

    return hashValue

def sqaure(x):
    return x * x;


def quickMatchCheck(path1, path2):

    #.1 second energy chunks
    info1 = getInfo(path1, 4410);
    info2 = getInfo(path2, 4410);

    fragmentSize = 50   
    distanceThreshold = 0.003
    returnThreshold = 0.001
    hashThresh = 100
    minDistance = 10000
    song1Time = -1
    song2Time = -2

    for i in range(0, len(info1["energies"]) - fragmentSize - 1):
        checkList = info2["hashDict"].get(info1["hashArr"][i])
        if checkList:
            for index in checkList:
                distance = dist.euclidean(info1["energies"][i:i+fragmentSize], info2["energies"][index:index+fragmentSize])
                #print "distance: " + str(distance) + " " + str(i * .1) + " " + str(index * .1)
                if distance < returnThreshold:
                    print "MATCH " + formatFileName(path1) + " " + formatFileName(path2) + " " + str(i * .1) + " " + str(index * .1)
                    return;
                if distance < distanceThreshold and distance < minDistance:
                    minDistance = distance
                    song1Time = i * .1
                    song2Time = index * .1

    if not minDistance == 10000:
        print "MATCH " + formatFileName(path1) + " " + formatFileName(path2) + " " + song1Time + " " + song2Time
        return


def matchCheck(path1, path2):

    #.1 second energy chunks
    info1 = getInfo(path1, 4410)["energies"];
    info2 = getInfo(path2, 4410)["energies"];

    fragmentSize = 50   
    distanceThreshold = 0.005

    hashThresh = 100
    #loop through all possible 5 sec fragments
    for i in range(0, len(info1) - fragmentSize):
        #loop through each possible 5 sec fragment
        for j in range(0, len(info2) - fragmentSize):
            distance = dist.euclidean(info1[i:i+fragmentSize], info2[j:j+fragmentSize])
            
            #print str(i * .1) + " " + str(j * .1) + " " + str(distance)
            if (distance < distanceThreshold):
                #print "distance: " + str(distance)
                print "MATCH " + formatFileName(path1) + " " + str(i * .1) + " " + formatFileName(path2) + " " + str(j * .1)
                return;

    #hash1 = hash(info1[0:50])
    #hash2 = hash(info2[0:50])

#MAIN
#check for valid command line input

if len(sys.argv) != 5 and len(sys.argv) != 6:
    throwError(1)    

if len(sys.argv) == 6:
    if sys.argv[5] == '--debug':
        DEBUG = True
    else: 
        throwError(1)
    
if ((sys.argv[1] != '-f' and sys.argv[1] != '-d') or
   (sys.argv[3] != '-f' and sys.argv[3] != '-d')):
    throwError(1)

pathList1 = []
pathList2 = []
if (sys.argv[1] == '-f'):
    pathList1.append(sys.argv[2])
elif (sys.argv[1] == '-d'):
    if os.path.exists(sys.argv[2]) and os.path.isdir(sys.argv[2]):
        files = os.listdir(sys.argv[2])
        for f in files:
            pathList1.append(os.path.join(sys.argv[2], f))        
    else:
        throwError(1)    
if (sys.argv[3] == '-f'):
    pathList2.append(sys.argv[4])
elif (sys.argv[3] == '-d'):
    if os.path.exists(sys.argv[4]) and os.path.isdir(sys.argv[4]):
        files = os.listdir(sys.argv[4])
        for f in files:
            pathList2.append(os.path.join(sys.argv[4], f))        
    else:
        throwError(1)

for s1 in pathList1:
    for s2 in pathList2:
        quickMatchCheck(s1, s2)

#exit with status of 0 as specified in directions
exit(0)

