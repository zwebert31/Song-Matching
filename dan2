#! /usr/bin/python

import sys
import wave
import struct
import numpy
import os.path
import scipy.io.wavfile
import scipy.fftpack
import os
import uuid
from subprocess import call
from multiprocessing.pool import ThreadPool

#Returns the length of the waveFile in seconds
def songLength(waveFile):	
    return waveFile.getnframes() / float(waveFile.getframerate())

#Print an error to standard error
#ERROR CODE 1: Invalid command line
#ERROR CODE 2: Invalid file format
def throwError(code, arg=""):
    if code == 1:
        sys.stderr.write("ERROR: incorrect command line\n")
    elif code == 2:
        sys.stderr.write("ERROR: " + formatFileName(arg)
                         + " is not a supported format\n")
    else:
        sys.stderr.write("ERROR: there was a problem\n")
    exit(code)

#returns the formatted name of the file
def formatFileName(path):
    tmp = []

    for i in range (0, len(path)):
        if path[i] == '/':
           tmp = []
        else:
           tmp.append(path[i])

    formatted_str = ''.join(tmp)
    return formatted_str

#returns the extension of the file
def getExtension(path):
    return os.path.splitext(path)[1]

#returns 1 if extension is valid, 0 if invalid
def isValidExtension(path):
    extension = getExtension(path)
    extensions = [".wav", ".mp3"]
    return extension in extensions

def average(x):
    return  (x[0] + x[1]) / 2

#convert a stereo byte vector to a mono signal
def stereoToMono(byteVector):
    print "Start stereo to mono conversion"
    arr = map(average, byteVector);
    print "End Stereo to mono conversion: " + str(len(byteVector))
    return arr

def fileToWave(filePath):
    if getExtension(filePath) == ".wav":
        return filePath

    basePath = "/tmp/waveFiles"
    tmpPath = os.path.join(basePath + str(uuid.uuid4()))
    if not os.path.exists(tmpPath):
        os.makedirs(tmpPath)

    formattedFileName = formatFileName(filePath)
    outputPath = os.path.join(tmpPath, "%s.mp3" % formattedFileName[:-4])
 
    call(["./lame","--resample", "44.1", "--decode", "--silent",
              filePath, outputPath
              ])

    return outputPath

#fftResult -> int
def fftId(fft):
    return numpy.argmax(fft)

def split_list(alist, wanted_parts=1):
    length = len(alist)
    return [ alist[i*length // wanted_parts: (i+1)*length // wanted_parts] 
             for i in range(wanted_parts) ]

def stereo_to_mono(wave_data, numThreads):
    pool = ThreadPool(processes=numThreads)
    
    sublists = split_list(wave_data, wanted_parts=16)
    arr = []    
    i = 0
    for sublist in sublists:
        async_result = pool.apply_async(stereoToMono, (wave_data, ))
        wave_mono = async_result.get()
        arr.push(wave_mono)
        i += 1
        print "got result " + i
    
    async_result = pool.apply_async(stereoToMono, (wave_data, ))
    mono = async_result.get()
    return mono

#file -> dictionary
def fileToDict(path): 
    try:
        channels = wave.open(path, 'r').getnchannels()
    except wave.Error:
        throwError(2, path)

    wave_results = scipy.io.wavfile.read(path)
    wave_data = wave_results[1]
    samplingRate = wave_results[0]
    sampleCount = len(wave_data)
    #wave1_data = wave1_data.astype(numpy.float)
    print "Channels: " + str(channels) 
    if (channels == 2):
        pool = ThreadPool(processes=1)
        async_result = pool.apply_async(stereoToMono, (wave_data, ))
        wave_mono = async_result.get()
        #wave_mono = stereoToMono(wave_data) 
    else:
        wave_mono = wave_data
    
    chunkSize = 4096
    songDict = {}
    for i in range(0, sampleCount / chunkSize):
        startBounds = i * chunkSize
        endBounds = (i+1) * chunkSize
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])
        print fftChunk[0]
        fingerPrint = fftId(fftChunk)
        
        if (fftId in songDict):
            songDict[fingerPrint] = songDict[fingerPrint].append(i)
        else:       
            songDict[fingerPrint] = [i]; 
    
    return songDict         

def compareTwo(path1, path2):
    dict1 = fileToDict(fileToWave(path1))
    dict2 = fileToDict(fileToWave(path2))

compareTwo(sys.argv[1], sys.argv[2])
            
