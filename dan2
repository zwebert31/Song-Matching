#! /usr/bin/python

import sys
import wave
import struct
import numpy
import os.path
import scipy.io.wavfile
import scipy.fftpack
import os
import uuid
from subprocess import call

# Enable / disables debug prints
DEBUG = False

# How much our fftId can be off by and still be considered the same
ALLOWED_MATCH_ERROR = 5

# Minimum percentage of matches that must be found in order to signify a match
MATCH_CERTAINTY = 60

# Chunk size
CHUNK_SIZE = 4410

# Time per chunk
CHUNK_TIME = .1

#Returns the length of the waveFile in seconds
def songLength(waveFile):	
    return waveFile.getnframes() / float(waveFile.getframerate())

#Print an error to standard error
#ERROR CODE 1: Invalid command line
#ERROR CODE 2: Invalid file format
def throwError(code, arg=""):
    if code == 1:
        sys.stderr.write("ERROR: incorrect command line\n")
    elif code == 2:
        sys.stderr.write("ERROR: " + formatFileName(arg)
                         + " is not a supported format\n")
    else:
        sys.stderr.write("ERROR: there was a problem\n")
    exit(code)

#returns the relative file name of the file
def formatFileName(path):
    tmp = []

    for i in range (0, len(path)):
        if path[i] == '/':
           tmp = []
        else:
           tmp.append(path[i])

    formatted_str = ''.join(tmp)
    return formatted_str

#returns the extension of the file
def getExtension(path):
    return os.path.splitext(path)[1]

#returns 1 if extension is valid, 0 if invalid
def isValidExtension(path):
    extension = getExtension(path)
    extensions = [".wav", ".mp3"]
    return extension in extensions

#convert a stereo byte vector to a mono signal
def stereoToMono(byteVector):
    return map(left, byteVector)

# Returns a path to a wav file.
# If the file is a wav file already, the input path is returned
# Otherwise the file is converted to a .wav file and stored in a /tmp path
def fileToWave(filePath):
    if getExtension(filePath) == ".wav":
        return filePath

    basePath = "/tmp/waveFiles"
    tmpPath = os.path.join(basePath + str(uuid.uuid4()))
    if not os.path.exists(tmpPath):
        os.makedirs(tmpPath)

    formattedFileName = formatFileName(filePath)
    outputPath = os.path.join(tmpPath, "%s.mp3" % formattedFileName[:-4])
 
    call(["./lame","--resample", "44.1", "--decode", "--silent",
              filePath, outputPath
              ])

    return outputPath

#fftResult -> int
def fftId(fft):
    fft = map(abs, fft)
    return numpy.argmax(fft[0:len(fft)])   
    
#file -> {"dict":dictionary, "data":array}
def fileToDict(path): 
    try:
        channels = wave.open(path, 'r').getnchannels()
    except wave.Error:
        throwError(2, path)

    wave_results = scipy.io.wavfile.read(path)
    wave_data = wave_results[1]
    samplingRate = wave_results[0]
    sampleCount = len(wave_data)

    if (channels == 2):
        wave_mono = wave_data.mean(axis=1)  
    else:
        wave_mono = wave_data
 
    songDict = {}
    chunks = []
    allFFT = []
    for i in range(0, sampleCount / CHUNK_SIZE):
        startBounds = i * CHUNK_SIZE
        endBounds = (i+1) * CHUNK_SIZE 
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])          
        allFFT.append(fftChunk);
        fingerPrint = fftId(fftChunk)
        chunks.append(fingerPrint)
        songDict.setdefault(fingerPrint,[]).append(i)  
    return {"dict":songDict,"data":chunks, "fft":allFFT}         

# Get the values from a dictionary where the key is within the range:
# key - allowedError to key + allowedError
def roundedDictGet(dic, key, allowedError, default):
     lower = key - allowedError;
     upper = key + allowedError;
     values = []
     for i in range(lower, upper):
         values.append(dic.get(i, default))
     return values

# Determines if path1 matches path2
def isMatch(path1, path2):
    #check for file exists
    if not os.path.isfile(path1) or not os.path.isfile(path2):
        throwError(1)

    if not (isValidExtension(path1)):
        throwError(2, wavePath1)
    if not (isValidExtension(path2)):
        throwError(2, path2)
 
    f1 = fileToDict(path1)
    f2 = fileToDict(path2)

    match = 0
    noMatch = 0
    compared = 0    
    f1Data = f1["data"]
    f2Dict = f2["dict"]
    matchFound = False
    maxCertainty = -1
    song1Time = 0
    song2Time = 0

    for i in range(0, len(f1Data)):
        # Get a list of all indices from the second song
        # which have the same audio fingerprint
        checkList = roundedDictGet(f2Dict, f1Data[i], 5, [])
	for value in checkList:
            for index in value:
                compared += 1
                matchInfo = getMatchInfo(f1Data, f2["data"], i, index, 50)     
                if matchInfo["isMatch"]:
                    if DEBUG:
                        print "Found match with certainty: " + str(maxCertainty)
                        print " at song 1 time: " + str(i * CHUNK_TIME)
                        print " and song 2 time: " + str(index * CHUNK_TIME)
                    # Get match with most certainty
                    if matchInfo["certainty"] > maxCertainty:
                        maxCertainty = matchInfo["certainty"]
                        song1Time = i * CHUNK_TIME
                        song2Time = index * CHUNK_TIME
                        if DEBUG:    
                            print "Setting new certainty to: " + str(maxCertainty)
                            print "Setting song 1 Time to: " + str(song1Time)
                            print "Setting song 2 Time to: " + str(song2Time)
    
    if maxCertainty == -1:
        return False
    else:
        if DEBUG:
            print "Final Certainty: " + str(maxCertainty)
            print "Final Song 1 Time: " + str(song1Time)
            print "Final Song 2 Time: " + str(song2Time)
        print "MATCH " + formatFileName(path1) + " " + formatFileName(path2) + " " + str(song1Time) + " " + str(song2Time) 
        return True

# Gets info about a match including if it is a match and the % certainty
def getMatchInfo(data1, data2, index1, index2, chunkCount):
    match = 0
    noMatch = 0
    data1_length = len(data1)
    data2_length = len(data2)
        
    if (data1_length <= index1 + chunkCount) or (data2_length <= index2 + chunkCount) or (index1 < 0) or (index2 < 0):
        return { "isMatch": False, "certainty": 100 }
    
    for i in range (0, chunkCount):
        diff = abs(data1[index1 + i] - data2[index2 + i])
        if diff < ALLOWED_MATCH_ERROR:
            match += 1
        else:
            noMatch += 1 
   
    certainty = (float(match) / float(chunkCount)) * 100
     
    return { "isMatch": certainty >= MATCH_CERTAINTY, "certainty": certainty }

#MAIN
#check for valid command line input
if len(sys.argv) != 5:
    throwError(1)    
    
if ((sys.argv[1] != '-f' and sys.argv[1] != '-d') or
   (sys.argv[3] != '-f' and sys.argv[3] != '-d')):
    throwError(1)

pathList1 = []
pathList2 = []
if (sys.argv[1] == '-f'):
    pathList1.append(fileToWave(sys.argv[2]))
elif (sys.argv[1] == '-d'):
    if os.path.exists(sys.argv[2]) and os.path.isdir(sys.argv[2]):
        files = os.listdir(sys.argv[2])
        for f in files:
            pathList1.append(fileToWave(os.path.join(sys.argv[2], f)))        
    else:
        throwError(1)    
if (sys.argv[3] == '-f'):
    pathList2.append(fileToWave(sys.argv[4]))
elif (sys.argv[3] == '-d'):
    if os.path.exists(sys.argv[4]) and os.path.isdir(sys.argv[4]):
        files = os.listdir(sys.argv[4])
        for f in files:
            pathList2.append(fileToWave(os.path.join(sys.argv[4], f)))        
    else:
        throwError(1)

for s1 in pathList1:
    for s2 in pathList2:
        isMatch(s1, s2)

#exit with status of 0 as specified in directions
exit(0)


