#! /usr/bin/python

import sys
import wave
import struct
import numpy
import os.path
import scipy.io.wavfile
import scipy.fftpack
import os
import uuid
from subprocess import call
from multiprocessing.pool import ThreadPool

#Returns the length of the waveFile in seconds
def songLength(waveFile):	
    return waveFile.getnframes() / float(waveFile.getframerate())

#Print an error to standard error
#ERROR CODE 1: Invalid command line
#ERROR CODE 2: Invalid file format
def throwError(code, arg=""):
    if code == 1:
        sys.stderr.write("ERROR: incorrect command line\n")
    elif code == 2:
        sys.stderr.write("ERROR: " + formatFileName(arg)
                         + " is not a supported format\n")
    else:
        sys.stderr.write("ERROR: there was a problem\n")
    exit(code)

#returns the formatted name of the file
def formatFileName(path):
    tmp = []

    for i in range (0, len(path)):
        if path[i] == '/':
           tmp = []
        else:
           tmp.append(path[i])

    formatted_str = ''.join(tmp)
    return formatted_str

#returns the extension of the file
def getExtension(path):
    return os.path.splitext(path)[1]

#returns 1 if extension is valid, 0 if invalid
def isValidExtension(path):
    extension = getExtension(path)
    extensions = [".wav", ".mp3"]
    return extension in extensions

def average(x):
    return  (x[0] + x[1]) / 2

def left(x):
    return x[0]

#convert a stereo byte vector to a mono signal
def stereoToMono(byteVector):
    print "Start stereo to mono conversion"
    arr = map(left, byteVector);
    print "End Stereo to mono conversion: " + str(len(byteVector))
    return arr

def fileToWave(filePath):
    if getExtension(filePath) == ".wav":
        return filePath

    basePath = "/tmp/waveFiles"
    tmpPath = os.path.join(basePath + str(uuid.uuid4()))
    if not os.path.exists(tmpPath):
        os.makedirs(tmpPath)

    formattedFileName = formatFileName(filePath)
    outputPath = os.path.join(tmpPath, "%s.mp3" % formattedFileName[:-4])
 
    call(["./lame","--resample", "44.1", "--decode", "--silent",
              filePath, outputPath
              ])

    return outputPath

#fftResult -> int
def fftId(fft):
    fft = map(abs, fft)
    #print fft    
    return numpy.argmax(fft[0:len(fft)])

#file -> {"dict":dictionary, "data":array}
def fileToDict(path): 
    try:
        channels = wave.open(path, 'r').getnchannels()
    except wave.Error:
        throwError(2, path)

    wave_results = scipy.io.wavfile.read(path)
    wave_data = wave_results[1]
    samplingRate = wave_results[0]
    sampleCount = len(wave_data)

    print "Channels: " + str(channels) 
    if (channels == 2):
        wave_mono = wave_data.mean(axis=1)  
    else:
        wave_mono = wave_data
    
    chunkSize = 4096 
    songDict = {}
    chunks = []
    for i in range(0, sampleCount / chunkSize):
        startBounds = i * chunkSize
        endBounds = (i+1) * chunkSize
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])          
        fingerPrint = fftId(fftChunk)
        chunks.append(fingerPrint)
        songDict.setdefault(fingerPrint,[]).append(i) 
    
    return {"dict":songDict,"data":chunks}         

#compare two of the same length, exact match
def compareTwo(path1, path2):
    data1 = fileToDict(fileToWave(path1))
    data2 = fileToDict(fileToWave(path2))
    match = 0;
    noMatch = 0
    for i in range(0, len(data1["data"])):
        if (data1["data"][i] == data2["data"][i]):
            match += 1;
        else:
            noMatch += 1;
    print match
    print noMatch

def partialCompare(path1, path2): 
    f1 = fileToDict(fileToWave(path1))
    f2 = fileToDict(fileToWave(path2))
    match = 0;
    noMatch = 0
    
    print f1["data"][960:1060]
    print f2["data"][370:470]
    
    f1Prints = f1["data"]
    f2Dict = f2["dict"]
    
#    for i in range(0, len(f1Prints)):
#        for j in range(0, len(f2["data"])):
#            checkIfMatch(f1Prints, f2["data"], i, j, 100)
    print f2["dict"]

    for i in range(0, len(f1Prints)):
        checkList = f2Dict.get(f1Prints[i], [])
        for index in checkList:
            l = 0      
   #   checkIfMatch(f1Prints, f2["data"], i, index, 50)
                
     
    #checkIfMatch(data1[1], data2[1], 1, 1, 10);
    #for i in range(0, len(data1[1])):    
    print len(f1["data"])    
    
def checkIfMatch(data1, data2, index1, index2, chunkCount):
    match = 0;
    noMatch = 0;
    
    data1_length = len(data1)
    data2_length = len(data2)
    zeros = 0    
    if (data1_length <= index1 + chunkCount) or (data2_length <= index2 + chunkCount) or (index1 < 0) or (index2 < 0):

#        print "out of bounds"
        return 0

    for i in range (0, chunkCount):
        if (data1[index1 + i] == data2[index2 + i]):
            if data1[index1 + i] == 0:
                zeros += 1
            match += 1;
        else:
            noMatch += 1;
    
    if (match >= chunkCount / 2):
        print str(.09 * index1) + " " + str(.09 * index2) + " Match: " + str(match) + ", No Match: " + str(noMatch) + " zeros: " + str(zeros)


partialCompare(sys.argv[1], sys.argv[2])
#compareTwo(sys.argv[1], sys.argv[2])
            
