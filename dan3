#! /usr/bin/python
#Zach Webert
#Katie Gilligan
#Sam Lynch
#Kevin Doherty

import sys
import wave
import numpy
import os.path
import scipy.io.wavfile
import scipy.spatial.distance as dist
import os
import uuid
from subprocess import call

# Enable / disables debug prints
DEBUG = False

# How much our fftId can be off by and still be considered the same
ALLOWED_MATCH_ERROR = 5

# Minimum percentage of matches that must 
# be found in order to signify a match
MATCH_CERTAINTY = 60

# Chunk size
CHUNK_SIZE = 4410

# Time per chunk
CHUNK_TIME = .1

# Cache which stores data about each song
# Key is the absolute path and value is the data
songDataCache = {}

#Print an error to standard error
#ERROR CODE 1: Invalid command line
#ERROR CODE 2: Invalid file format
def throwError(code, arg=""):
    if code == 1:
        sys.stderr.write("ERROR: incorrect command line\n")
    elif code == 2:
        sys.stderr.write("ERROR: " + formatFileName(arg)
                         + " is not a supported format\n")
    else:
        sys.stderr.write("ERROR: there was a problem\n")
    exit(code)

#returns the relative file name of the file
def formatFileName(path):
    tmp = []

    for i in range (0, len(path)):
        if path[i] == '/':
           tmp = []
        else:
           tmp.append(path[i])

    formatted_str = ''.join(tmp)
    return formatted_str

#returns the extension of the file
def getExtension(path):
    return os.path.splitext(path)[1]

#returns 1 if extension is valid, 0 if invalid
def isValidExtension(path):
    extension = getExtension(path)
    extensions = [".wav", ".mp3"]
    return extension in extensions

# Returns a path to a wav file.
# If the file is a wav file already, the input path is returned
# Otherwise the file is converted to a .wav file and stored in a /tmp path
def fileToWave(filePath):
    if getExtension(filePath) == ".wav":
        return filePath

    basePath = "/tmp/waveFiles"
    tmpPath = os.path.join(basePath + str(uuid.uuid4()))

    if not os.path.exists(tmpPath):
        os.makedirs(tmpPath)

    formattedFileName = formatFileName(filePath)
    outputPath = os.path.join(tmpPath, "%s.mp3" % formattedFileName[:-4])
 
    call(["./lame","--resample", "44.1", "--decode", "--silent",
              filePath, outputPath
              ])

    return outputPath

#fftResult -> int
def fftId(fft):
    # Gets the magnitude of each complex number
    fft = map(abs, fft)
    # Return the frequency which occurs most 
    return numpy.argmax(fft)   
    
#file -> {"dict":dictionary, "data":array}
def fileToDict(path):
    if path in songDataCache:
        return songDataCache[path]

    try:
        channels = wave.open(path, 'r').getnchannels()
    except wave.Error:
        throwError(2, path)

    wave_results = scipy.io.wavfile.read(path)
    
    samplingRate = wave_results[0]
    # Array of samples
    wave_data = wave_results[1]
    sampleCount = len(wave_data)

    if (channels == 2):
        # Convert stereo to mono by averaging the channels 
        wave_mono = wave_data.mean(axis=1)  
    else:
        wave_mono = wave_data
 
    # Dictionary where keys are fingerprints and values are list of
    # indicies of the chunks that contain that fingerprint
    songDict = {}
    # Array of fingerprints
    chunks = []
    # Array of fft chunks
    allFFT = []
    for i in range(0, sampleCount / CHUNK_SIZE):
        startBounds = i * CHUNK_SIZE
        endBounds = (i+1) * CHUNK_SIZE 
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])          
        allFFT.append(fftChunk)
        fingerPrint = fftId(fftChunk)
        chunks.append(fingerPrint)
        songDict.setdefault(fingerPrint,[]).append(i)
  
    result = { "dict":songDict, "data":chunks, "fft":allFFT }
    songDataCache[path] = result

    return result        

# Get the values from a dictionary where the key is within the range:
# key - allowedError to key + allowedError
def roundedDictGet(dic, key, allowedError, default):
     lower = key - allowedError
     upper = key + allowedError
     values = []
     for i in range(lower, upper):
         values.append(dic.get(i, default))
     return values

# Determines if path1 matches path2
def isMatch(path1, path2):
    #check for file exists
    if not os.path.isfile(path1) or not os.path.isfile(path2):
        throwError(1)

    if not (isValidExtension(path1)):
        throwError(2, wavePath1)
    if not (isValidExtension(path2)):
        throwError(2, path2)
 
    f1 = fileToDict(path1)
    f2 = fileToDict(path2)

    f1Data = f1["data"]
    f2Dict = f2["dict"]
    matchFound = False
    maxCertainty = -1
    song1Time = 0
    song2Time = 0

    for i in range(0, len(f1Data)):
        # Get a list of all indices from the second song
        # which have the same audio fingerprint
        checkList = roundedDictGet(f2Dict, f1Data[i], 5, [])
	for value in checkList:
            for index in value:
                matchInfo = getMatchInfo(f1Data, f2["data"], i, index, 50)     
                if matchInfo["isMatch"]:
                    # Get match with most certainty
                    if matchInfo["certainty"] > maxCertainty:
                        maxCertainty = matchInfo["certainty"]
                        song1Time = i * CHUNK_TIME
                        song2Time = index * CHUNK_TIME
                        if DEBUG:
                            print "Setting song1Time to " + str(song1Time)
                            print "Setting song2Time to " + str(song2Time)
    
    if maxCertainty == -1:
        return False
    else:
        if DEBUG:
            print "Final Certainty: " + str(maxCertainty)
        print ("MATCH " + formatFileName(path1) + " " +
               formatFileName(path2) + " " +
               str(song1Time) + " " + str(song2Time)) 
        return True

# Gets info about a match including if it is a match and the % certainty
def getMatchInfo(data1, data2, index1, index2, chunkCount):
    match = 0
    noMatch = 0
    data1_length = len(data1)
    data2_length = len(data2)
        
    if ((data1_length <= index1 + chunkCount)
         or (data2_length <= index2 + chunkCount) 
         or (index1 < 0) or (index2 < 0)):
        return { "isMatch": False, "certainty": 100 }
    
    for i in range (0, chunkCount):
        diff = abs(data1[index1 + i] - data2[index2 + i])
        if diff < ALLOWED_MATCH_ERROR:
            match += 1
        else:
            noMatch += 1 
   
    certainty = (float(match) / float(chunkCount)) * 100
     
    return { "isMatch": certainty >= MATCH_CERTAINTY,
             "certainty": certainty }

#path to wavfile -> 
def getInfo(path, chunkSize):
    #TODO remove
    path = fileToWave(path);

    wave_results = scipy.io.wavfile.read(path)
    samplingRate = wave_results[0]
    # Array of samples
    wave_data = wave_results[1]
    sampleCount = len(wave_data)

    channels = wave.open(path, 'r').getnchannels()
    if (channels == 2):
        # Convert stereo to mono by averaging the channels 
        #wave_mono = [[x[0] & 0xFF, x[1] & 0xFF] for x in wave_data]
        wave_mono = wave_data.mean(axis=1)  
    else:
        #wave_mono = [x & 0xFF for x in wave_data]
        wave_mono = wave_data
        

    
    
    songDict = {}
    chunks = []
    allFFT = []
    for i in range(0, sampleCount / chunkSize):
        startBounds = i * chunkSize
        endBounds = (i+1) * chunkSize 
        fftChunk = numpy.fft.fft(wave_mono[startBounds:endBounds])          

        fftChunk = map(abs, fftChunk)
        fftChunk = map(sqaure, fftChunk)
        fftMax = numpy.amax(fftChunk)
        if (fftMax == 0):
            fftMax = 1
        fftChunk = [x / len(fftChunk) / fftMax for x in fftChunk]
        chunks.append(numpy.sum(fftChunk))

    return chunks;

def hash(chunkArray):
    weight = 1
    hashValue = 0;
    for x in chunkArray:
        hashValue += (x * weight)
        weight += 1;

    return hashValue

def sqaure(x):
    return x * x + 0;

def matchCheck(path1, path2):

    #.1 second energy chunks
    info1 = getInfo(path1, 4410);
    info2 = getInfo(path2, 4410);

    fragmentSize = 50   
    distanceThreshold = 0.005
    hashThresh = 100
    #loop through all possible 5 sec fragments
    for i in range(0, len(info1) - fragmentSize):
        #loop through each possible 5 sec fragment
        for j in range(0, len(info2) - fragmentSize):
            distance = dist.euclidean(info1[i:i+fragmentSize], info2[j:j+fragmentSize])
           
            #print str(i * .1) + " " + str(j * .1) + " " + str(distance)
            if (distance < distanceThreshold):
                print "MATCH " + str(i * .1) + " " + str(j * .1) + " " + str(distance)

    #hash1 = hash(info1[0:50])
    #hash2 = hash(info2[0:50])

#MAIN
matchCheck(sys.argv[1], sys.argv[2])

#exit with status of 0 as specified in directions
exit(0)
